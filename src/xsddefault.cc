/*
** Copyright 2000-2009      Ethan Galstad
** Copyright 2009           Nagios Core Development Team and Community
*Contributors
** Copyright 2011-2013,2015 Merethis
**
** This file is part of Centreon Engine.
**
** Centreon Engine is free software: you can redistribute it and/or
** modify it under the terms of the GNU General Public License version 2
** as published by the Free Software Foundation.
**
** Centreon Engine is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with Centreon Engine. If not, see
** <http://www.gnu.org/licenses/>.
*/

#include <iostream>

#include "com/centreon/engine/xsddefault.hh"

#include <fmt/format.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#include <cerrno>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <sstream>
#include <string>

#include "com/centreon/engine/comment.hh"
#include "com/centreon/engine/common.hh"
#include "com/centreon/engine/configuration/applier/state.hh"
#include "com/centreon/engine/contact.hh"
#include "com/centreon/engine/downtimes/service_downtime.hh"
#include "com/centreon/engine/downtimes/downtime_manager.hh"
#include "com/centreon/engine/globals.hh"
#include "com/centreon/engine/logging/logger.hh"
#include "com/centreon/engine/macros.hh"
#include "com/centreon/engine/statusdata.hh"

using namespace com::centreon;
using namespace com::centreon::engine;
using namespace com::centreon::engine::downtimes;
using namespace com::centreon::engine::configuration::applier;

static int xsddefault_status_log_fd(-1);

/******************************************************************/
/********************* INIT/CLEANUP FUNCTIONS *********************/
/******************************************************************/

/* initialize status data */
int xsddefault_initialize_status_data() {
  if (verify_config || config->status_file().empty())
    return OK;

  if (xsddefault_status_log_fd == -1) {
    // delete the old status log (it might not exist).
    unlink(config->status_file().c_str());

    if ((xsddefault_status_log_fd =
             open(config->status_file().c_str(), O_WRONLY | O_CREAT,
                  S_IRUSR | S_IWUSR | S_IRGRP)) == -1) {
      logger(engine::logging::log_runtime_error, engine::logging::basic)
          << "Error: Unable to open status data file '" << config->status_file()
          << "': " << strerror(errno);
      return ERROR;
    }
    set_cloexec(xsddefault_status_log_fd);
  }
  return OK;
}

// cleanup status data before terminating.
int xsddefault_cleanup_status_data(int delete_status_data) {
  if (verify_config)
    return OK;

  // delete the status log.
  if (delete_status_data && !config->status_file().empty()) {
    if (unlink(config->status_file().c_str()))
      return ERROR;
  }

  if (xsddefault_status_log_fd != -1) {
    close(xsddefault_status_log_fd);
    xsddefault_status_log_fd = -1;
  }
  return OK;
}

/******************************************************************/
/****************** STATUS DATA OUTPUT FUNCTIONS ******************/
/******************************************************************/

/* write all status data to file */
int xsddefault_save_status_data() {
  auto start = std::chrono::steady_clock::now();

  if (xsddefault_status_log_fd == -1)
    return OK;

  int used_external_command_buffer_slots(0);
  int high_external_command_buffer_slots(0);

  logger(engine::logging::dbg_functions, engine::logging::basic)
      << "save_status_data()";

  // get number of items in the command buffer
  if (config->check_external_commands()) {
    // FIXME DBR
    pthread_mutex_lock(&external_command_buffer.buffer_lock);
    used_external_command_buffer_slots = external_command_buffer.items;
    high_external_command_buffer_slots = external_command_buffer.high;
    pthread_mutex_unlock(&external_command_buffer.buffer_lock);
  }

  // generate check statistics
  generate_check_stats();

  std::ostringstream stream;

  time_t current_time;
  time(&current_time);

  // write version info to status file
  stream << "#############################################\n"
            "#        CENTREON ENGINE STATUS FILE        #\n"
            "#                                           #\n"
            "# THIS FILE IS AUTOMATICALLY GENERATED BY   #\n"
            "# CENTREON ENGINE. DO NOT MODIFY THIS FILE! #\n"
            "#############################################\n"
            "\n"
            "info {\n"
            "\tcreated="
         << static_cast<unsigned long>(current_time)
         << "\n"
            "\t}\n\n";

  // save program status data
  stream
      << "programstatus {\n"
         "\tmodified_host_attributes="
      << modified_host_process_attributes
      << "\n"
         "\tmodified_service_attributes="
      << modified_service_process_attributes
      << "\n"
         "\tnagios_pid="
      << static_cast<unsigned int>(getpid())
      << "\n"
         "\tprogram_start="
      << static_cast<long long>(program_start)
      << "\n"
         "\tgrpc_port="
      << grpc_port
      << "\n"
         "\tlast_command_check="
      << static_cast<long long>(last_command_check)
      << "\n"
         "\tlast_log_rotation="
      << static_cast<long long>(last_log_rotation)
      << "\n"
         "\tenable_notifications="
      << config->enable_notifications()
      << "\n"
         "\tactive_service_checks_enabled="
      << config->execute_service_checks()
      << "\n"
         "\tpassive_service_checks_enabled="
      << config->accept_passive_service_checks()
      << "\n"
         "\tactive_host_checks_enabled="
      << config->execute_host_checks()
      << "\n"
         "\tpassive_host_checks_enabled="
      << config->accept_passive_host_checks()
      << "\n"
         "\tenable_event_handlers="
      << config->enable_event_handlers()
      << "\n"
         "\tobsess_over_services="
      << config->obsess_over_services()
      << "\n"
         "\tobsess_over_hosts="
      << config->obsess_over_hosts()
      << "\n"
         "\tcheck_service_freshness="
      << config->check_service_freshness()
      << "\n"
         "\tcheck_host_freshness="
      << config->check_host_freshness()
      << "\n"
         "\tenable_flap_detection="
      << config->enable_flap_detection()
      << "\n"
         "\tprocess_performance_data="
      << config->process_performance_data()
      << "\n"
         "\tglobal_host_event_handler="
      << config->global_host_event_handler()
      << "\n"
         "\tglobal_service_event_handler="
      << config->global_service_event_handler()
      << "\n"
         "\tnext_comment_id="
      << comment::get_next_comment_id()
      << "\n"
         "\tnext_event_id="
      << next_event_id
      << "\n"
         "\tnext_problem_id="
      << next_problem_id
      << "\n"
         "\tnext_notification_id="
      << next_notification_id
      << "\n"
         "\ttotal_external_command_buffer_slots="
      << config->external_command_buffer_slots()
      << "\n"
         "\tused_external_command_buffer_slots="
      << used_external_command_buffer_slots
      << "\n"
         "\thigh_external_command_buffer_slots="
      << high_external_command_buffer_slots
      << "\n"
         "\tactive_scheduled_host_check_stats="
      << check_statistics[ACTIVE_SCHEDULED_HOST_CHECK_STATS].minute_stats[0]
      << ","
      << check_statistics[ACTIVE_SCHEDULED_HOST_CHECK_STATS].minute_stats[1]
      << ","
      << check_statistics[ACTIVE_SCHEDULED_HOST_CHECK_STATS].minute_stats[2]
      << "\n"
         "\tactive_ondemand_host_check_stats="
      << check_statistics[ACTIVE_ONDEMAND_HOST_CHECK_STATS].minute_stats[0]
      << ","
      << check_statistics[ACTIVE_ONDEMAND_HOST_CHECK_STATS].minute_stats[1]
      << ","
      << check_statistics[ACTIVE_ONDEMAND_HOST_CHECK_STATS].minute_stats[2]
      << "\n"
         "\tpassive_host_check_stats="
      << check_statistics[PASSIVE_HOST_CHECK_STATS].minute_stats[0] << ","
      << check_statistics[PASSIVE_HOST_CHECK_STATS].minute_stats[1] << ","
      << check_statistics[PASSIVE_HOST_CHECK_STATS].minute_stats[2]
      << "\n"
         "\tactive_scheduled_service_check_stats="
      << check_statistics[ACTIVE_SCHEDULED_SERVICE_CHECK_STATS].minute_stats[0]
      << ","
      << check_statistics[ACTIVE_SCHEDULED_SERVICE_CHECK_STATS].minute_stats[1]
      << ","
      << check_statistics[ACTIVE_SCHEDULED_SERVICE_CHECK_STATS].minute_stats[2]
      << "\n"
         "\tactive_ondemand_service_check_stats="
      << check_statistics[ACTIVE_ONDEMAND_SERVICE_CHECK_STATS].minute_stats[0]
      << ","
      << check_statistics[ACTIVE_ONDEMAND_SERVICE_CHECK_STATS].minute_stats[1]
      << ","
      << check_statistics[ACTIVE_ONDEMAND_SERVICE_CHECK_STATS].minute_stats[2]
      << "\n"
         "\tpassive_service_check_stats="
      << check_statistics[PASSIVE_SERVICE_CHECK_STATS].minute_stats[0] << ","
      << check_statistics[PASSIVE_SERVICE_CHECK_STATS].minute_stats[1] << ","
      << check_statistics[PASSIVE_SERVICE_CHECK_STATS].minute_stats[2]
      << "\n"
         "\tcached_host_check_stats="
      << check_statistics[ACTIVE_CACHED_HOST_CHECK_STATS].minute_stats[0] << ","
      << check_statistics[ACTIVE_CACHED_HOST_CHECK_STATS].minute_stats[1] << ","
      << check_statistics[ACTIVE_CACHED_HOST_CHECK_STATS].minute_stats[2]
      << "\n"
         "\tcached_service_check_stats="
      << check_statistics[ACTIVE_CACHED_SERVICE_CHECK_STATS].minute_stats[0]
      << ","
      << check_statistics[ACTIVE_CACHED_SERVICE_CHECK_STATS].minute_stats[1]
      << ","
      << check_statistics[ACTIVE_CACHED_SERVICE_CHECK_STATS].minute_stats[2]
      << "\n"
         "\texternal_command_stats="
      << check_statistics[EXTERNAL_COMMAND_STATS].minute_stats[0] << ","
      << check_statistics[EXTERNAL_COMMAND_STATS].minute_stats[1] << ","
      << check_statistics[EXTERNAL_COMMAND_STATS].minute_stats[2]
      << "\n"
         "\tparallel_host_check_stats="
      << check_statistics[PARALLEL_HOST_CHECK_STATS].minute_stats[0] << ","
      << check_statistics[PARALLEL_HOST_CHECK_STATS].minute_stats[1] << ","
      << check_statistics[PARALLEL_HOST_CHECK_STATS].minute_stats[2]
      << "\n"
         "\tserial_host_check_stats="
      << check_statistics[SERIAL_HOST_CHECK_STATS].minute_stats[0] << ","
      << check_statistics[SERIAL_HOST_CHECK_STATS].minute_stats[1] << ","
      << check_statistics[SERIAL_HOST_CHECK_STATS].minute_stats[2]
      << "\n"
         "\t}\n\n";

  /* save host status data */
  for (host_map::iterator it(com::centreon::engine::host::hosts.begin()),
       end(com::centreon::engine::host::hosts.end());
       it != end; ++it) {
    stream
        << "hoststatus {\n"
           "\thost_name="
        << it->second->get_name()
        << "\n"
           "\tmodified_attributes="
        << it->second->get_modified_attributes()
        << "\n"
           "\tcheck_command="
        << it->second->get_check_command()
        << "\n"
           "\tcheck_period="
        << it->second->get_check_period()
        << "\n"
           "\tnotification_period="
        << it->second->get_notification_period()
        << "\n"
           "\tcheck_interval="
        << it->second->get_check_interval()
        << "\n"
           "\tretry_interval="
        << it->second->get_retry_interval()
        << "\n"
           "\tevent_handler="
        << it->second->get_event_handler()
        << "\n"
           "\thas_been_checked="
        << it->second->has_been_checked()
        << "\n"
           "\tshould_be_scheduled="
        << it->second->get_should_be_scheduled()
        << "\n"
           "\tcheck_execution_time="
        << std::setprecision(3) << std::fixed
        << it->second->get_execution_time()
        << "\n"
           "\tcheck_latency="
        << std::setprecision(3) << std::fixed << it->second->get_latency()
        << "\n"
           "\tcheck_type="
        << it->second->get_check_type()
        << "\n"
           "\tcurrent_state="
        << it->second->get_current_state()
        << "\n"
           "\tlast_hard_state="
        << it->second->get_last_hard_state()
        << "\n"
           "\tlast_event_id="
        << it->second->get_last_event_id()
        << "\n"
           "\tcurrent_event_id="
        << it->second->get_current_event_id()
        << "\n"
           "\tcurrent_problem_id="
        << it->second->get_current_problem_id()
        << "\n"
           "\tlast_problem_id="
        << it->second->get_last_problem_id()
        << "\n"
           "\tplugin_output="
        << it->second->get_plugin_output()
        << "\n"
           "\tlong_plugin_output="
        << it->second->get_long_plugin_output()
        << "\n"
           "\tperformance_data="
        << it->second->get_perf_data()
        << "\n"
           "\tlast_check="
        << static_cast<unsigned long>(it->second->get_last_check())
        << "\n"
           "\tnext_check="
        << static_cast<unsigned long>(it->second->get_next_check())
        << "\n"
           "\tcheck_options="
        << it->second->get_check_options()
        << "\n"
           "\tcurrent_attempt="
        << it->second->get_current_attempt()
        << "\n"
           "\tmax_attempts="
        << it->second->get_max_attempts()
        << "\n"
           "\tstate_type="
        << it->second->get_state_type()
        << "\n"
           "\tlast_state_change="
        << static_cast<unsigned long>(it->second->get_last_state_change())
        << "\n"
           "\tlast_hard_state_change="
        << static_cast<unsigned long>(it->second->get_last_hard_state_change())
        << "\n"
           "\tlast_time_up="
        << static_cast<unsigned long>(it->second->get_last_time_up())
        << "\n"
           "\tlast_time_down="
        << static_cast<unsigned long>(it->second->get_last_time_down())
        << "\n"
           "\tlast_time_unreachable="
        << static_cast<unsigned long>(it->second->get_last_time_unreachable())
        << "\n"
           "\tlast_notification="
        << static_cast<unsigned long>(it->second->get_last_notification())
        << "\n"
           "\tnext_notification="
        << static_cast<unsigned long>(it->second->get_next_notification())
        << "\n"
           "\tno_more_notifications="
        << it->second->get_no_more_notifications()
        << "\n"
           "\tcurrent_notification_number="
        << it->second->get_notification_number()
        << "\n"
           "\tcurrent_notification_id="
        << it->second->get_current_notification_id()
        << "\n"
           "\tnotifications_enabled="
        << it->second->get_notifications_enabled()
        << "\n"
           "\tproblem_has_been_acknowledged="
        << it->second->get_problem_has_been_acknowledged()
        << "\n"
           "\tacknowledgement_type="
        << it->second->get_acknowledgement_type()
        << "\n"
           "\tactive_checks_enabled="
        << it->second->get_checks_enabled()
        << "\n"
           "\tpassive_checks_enabled="
        << it->second->get_accept_passive_checks()
        << "\n"
           "\tevent_handler_enabled="
        << it->second->get_event_handler_enabled()
        << "\n"
           "\tflap_detection_enabled="
        << it->second->get_flap_detection_enabled()
        << "\n"
           "\tprocess_performance_data="
        << it->second->get_process_performance_data()
        << "\n"
           "\tobsess_over_host="
        << it->second->get_obsess_over()
        << "\n"
           "\tlast_update="
        << static_cast<unsigned long>(current_time)
        << "\n"
           "\tis_flapping="
        << it->second->get_is_flapping()
        << "\n"
           "\tpercent_state_change="
        << std::setprecision(2) << std::fixed
        << it->second->get_percent_state_change()
        << "\n"
           "\tscheduled_downtime_depth="
        << it->second->get_scheduled_downtime_depth() << "\n";

    // custom variables
    for (auto const& cv : it->second->custom_variables) {
      if (!cv.first.empty())
        stream << "\t_" << cv.first << "=" << cv.second.has_been_modified()
               << ";" << cv.second.get_value() << "\n";
    }
    stream << "\t}\n\n";
  }

  // save service status data
  for (service_map::iterator it(service::services.begin()),
       end(service::services.end());
       it != end; ++it) {
    stream << "servicestatus {\n"
              "\thost_name="
           << it->second->get_hostname()
           << "\n"
              "\tservice_description="
           << it->second->get_description()
           << "\n"
              "\tmodified_attributes="
           << it->second->get_modified_attributes()
           << "\n"
              "\tcheck_command="
           << it->second->get_check_command()
           << "\n"
              "\tcheck_period="
           << it->second->get_check_period()
           << "\n"
              "\tnotification_period="
           << it->second->get_notification_period()
           << "\n"
              "\tcheck_interval="
           << it->second->get_check_interval()
           << "\n"
              "\tretry_interval="
           << it->second->get_retry_interval()
           << "\n"
              "\tevent_handler="
           << it->second->get_event_handler()
           << "\n"
              "\thas_been_checked="
           << it->second->has_been_checked()
           << "\n"
              "\tshould_be_scheduled="
           << it->second->get_should_be_scheduled()
           << "\n"
              "\tcheck_execution_time="
           << std::setprecision(3) << std::fixed
           << it->second->get_execution_time()
           << "\n"
              "\tcheck_latency="
           << std::setprecision(3) << std::fixed << it->second->get_latency()
           << "\n"
              "\tcheck_type="
           << it->second->get_check_type()
           << "\n"
              "\tcurrent_state="
           << it->second->get_current_state()
           << "\n"
              "\tlast_hard_state="
           << it->second->get_last_hard_state()
           << "\n"
              "\tlast_event_id="
           << it->second->get_last_event_id()
           << "\n"
              "\tcurrent_event_id="
           << it->second->get_current_event_id()
           << "\n"
              "\tcurrent_problem_id="
           << it->second->get_current_problem_id()
           << "\n"
              "\tlast_problem_id="
           << it->second->get_last_problem_id()
           << "\n"
              "\tcurrent_attempt="
           << it->second->get_current_attempt()
           << "\n"
              "\tmax_attempts="
           << it->second->get_max_attempts()
           << "\n"
              "\tstate_type="
           << it->second->get_state_type()
           << "\n"
              "\tlast_state_change="
           << static_cast<unsigned long>(it->second->get_last_state_change())
           << "\n"
              "\tlast_hard_state_change="
           << static_cast<unsigned long>(
                  it->second->get_last_hard_state_change())
           << "\n"
              "\tlast_time_ok="
           << static_cast<unsigned long>(it->second->get_last_time_ok())
           << "\n"
              "\tlast_time_warning="
           << static_cast<unsigned long>(it->second->get_last_time_warning())
           << "\n"
              "\tlast_time_unknown="
           << static_cast<unsigned long>(it->second->get_last_time_unknown())
           << "\n"
              "\tlast_time_critical="
           << static_cast<unsigned long>(it->second->get_last_time_critical())
           << "\n"
              "\tplugin_output="
           << it->second->get_plugin_output()
           << "\n"
              "\tlong_plugin_output="
           << it->second->get_long_plugin_output()
           << "\n"
              "\tperformance_data="
           << it->second->get_perf_data()
           << "\n"
              "\tlast_check="
           << static_cast<unsigned long>(it->second->get_last_check())
           << "\n"
              "\tnext_check="
           << static_cast<unsigned long>(it->second->get_next_check())
           << "\n"
              "\tcheck_options="
           << it->second->get_check_options()
           << "\n"
              "\tcurrent_notification_number="
           << it->second->get_notification_number()
           << "\n"
              "\tcurrent_notification_id="
           << it->second->get_current_notification_id()
           << "\n"
              "\tlast_notification="
           << static_cast<unsigned long>(it->second->get_last_notification())
           << "\n"
              "\tnext_notification="
           << static_cast<unsigned long>(it->second->get_next_notification())
           << "\n"
              "\tno_more_notifications="
           << it->second->get_no_more_notifications()
           << "\n"
              "\tnotifications_enabled="
           << it->second->get_notifications_enabled()
           << "\n"
              "\tactive_checks_enabled="
           << it->second->get_checks_enabled()
           << "\n"
              "\tpassive_checks_enabled="
           << it->second->get_accept_passive_checks()
           << "\n"
              "\tevent_handler_enabled="
           << it->second->get_event_handler_enabled()
           << "\n"
              "\tproblem_has_been_acknowledged="
           << it->second->get_problem_has_been_acknowledged()
           << "\n"
              "\tacknowledgement_type="
           << it->second->get_acknowledgement_type()
           << "\n"
              "\tflap_detection_enabled="
           << it->second->get_flap_detection_enabled()
           << "\n"
              "\tprocess_performance_data="
           << it->second->get_process_performance_data()
           << "\n"
              "\tobsess_over_service="
           << it->second->get_obsess_over()
           << "\n"
              "\tlast_update="
           << static_cast<unsigned long>(current_time)
           << "\n"
              "\tis_flapping="
           << it->second->get_is_flapping()
           << "\n"
              "\tpercent_state_change="
           << std::setprecision(2) << std::fixed
           << it->second->get_percent_state_change()
           << "\n"
              "\tscheduled_downtime_depth="
           << it->second->get_scheduled_downtime_depth() << "\n";

    // custom variables
    for (auto const& cv : it->second->custom_variables) {
      if (!cv.first.empty())
        stream << "\t_" << cv.first << "=" << cv.second.has_been_modified()
               << ";" << cv.second.get_value() << "\n";
    }
    stream << "\t}\n\n";
  }

  // save contact status data
  for (contact_map::const_iterator it{contact::contacts.begin()},
       end{contact::contacts.end()};
       it != end; ++it) {
    contact* cntct(it->second.get());
    stream << "contactstatus {\n"
              "\tcontact_name="
           << cntct->get_name()
           << "\n"
              "\tmodified_attributes="
           << cntct->get_modified_attributes()
           << "\n"
              "\tmodified_host_attributes="
           << cntct->get_modified_host_attributes()
           << "\n"
              "\tmodified_service_attributes="
           << cntct->get_modified_service_attributes()
           << "\n"
              "\thost_notification_period="
           << cntct->get_host_notification_period()
           << "\n"
              "\tservice_notification_period="
           << cntct->get_service_notification_period()
           << "\n"
              "\tlast_host_notification="
           << static_cast<unsigned long>(cntct->get_last_host_notification())
           << "\n"
              "\tlast_service_notification="
           << static_cast<unsigned long>(cntct->get_last_service_notification())
           << "\n"
              "\thost_notifications_enabled="
           << cntct->get_host_notifications_enabled()
           << "\n"
              "\tservice_notifications_enabled="
           << cntct->get_service_notifications_enabled() << "\n";
    // custom variables
    for (auto const& cv : cntct->get_custom_variables()) {
      if (!cv.first.empty())
        stream << "\t_" << cv.first << "=" << cv.second.has_been_modified()
               << ";" << cv.second.get_value() << "\n";
    }
    stream << "\t}\n\n";
  }

  // save all comments
  for (comment_map::iterator it(comment::comments.begin()),
       end(comment::comments.end());
       it != end; ++it) {
    if (it->second->get_comment_type() == com::centreon::engine::comment::host)
      stream << "hostcomment {\n";
    else
      stream << "servicecomment {\n";
    stream << "\thost_id=" << it->second->get_host_id() << "\n";
    if (it->second->get_comment_type() ==
        com::centreon::engine::comment::service)
      stream << "\tservice_id=" << it->second->get_service_id() << "\n";
    stream << "\tentry_type=" << it->second->get_entry_type()
           << "\n"
              "\tcomment_id="
           << it->first
           << "\n"
              "\tsource="
           << it->second->get_source()
           << "\n"
              "\tpersistent="
           << it->second->get_persistent()
           << "\n"
              "\tentry_time="
           << static_cast<unsigned long>(it->second->get_entry_time())
           << "\n"
              "\texpires="
           << it->second->get_expires()
           << "\n"
              "\texpire_time="
           << static_cast<unsigned long>(it->second->get_expire_time())
           << "\n"
              "\tauthor="
           << it->second->get_author()
           << "\n"
              "\tcomment_data="
           << it->second->get_comment_data()
           << "\n"
              "\t}\n\n";
  }

  // save all downtime
  for (std::pair<time_t, std::shared_ptr<downtime>> const& dt :
       downtime_manager::instance().get_scheduled_downtimes())
    stream << *dt.second;

  // Write data in buffer.
  stream.flush();

  // Prepare status file for overwrite.
  if (ftruncate(xsddefault_status_log_fd, 0) == -1 ||
      fsync(xsddefault_status_log_fd) == -1 ||
      lseek(xsddefault_status_log_fd, 0, SEEK_SET) == (off_t)-1) {
    char const* msg(strerror(errno));
    logger(engine::logging::log_runtime_error, engine::logging::basic)
        << "Error: Unable to update status data file '" << config->status_file()
        << "': " << msg;
    return ERROR;
  }

  // Write status file.
  std::string data(stream.str());
  char const* data_ptr(data.c_str());
  unsigned int size(data.size());
  while (size > 0) {
    ssize_t wb(write(xsddefault_status_log_fd, data_ptr, size));
    if (wb <= 0) {
      char const* msg(strerror(errno));
      logger(engine::logging::log_runtime_error, engine::logging::basic)
          << "Error: Unable to update status data file '"
          << config->status_file() << "': " << msg;
      return ERROR;
    }
    data_ptr += wb;
    size -= wb;
  }

  auto finish = std::chrono::steady_clock::now();
  time_t now = time(nullptr);
  std::cout << "### Status file Duration : " << std::chrono::duration_cast<std::chrono::duration<double>>(finish-start).count() << " ; " << (now - program_start) << std::endl;

  return OK;
}

int xsddefault_save_status_data1() {
  fmt::memory_buffer buf;

  auto start = std::chrono::steady_clock::now();

  if (xsddefault_status_log_fd == -1)
    return OK;

  int used_external_command_buffer_slots(0);
  int high_external_command_buffer_slots(0);

  logger(engine::logging::dbg_functions, engine::logging::basic)
      << "save_status_data()";

  // get number of items in the command buffer
  if (config->check_external_commands()) {
    // FIXME DBR
    pthread_mutex_lock(&external_command_buffer.buffer_lock);
    used_external_command_buffer_slots = external_command_buffer.items;
    high_external_command_buffer_slots = external_command_buffer.high;
    pthread_mutex_unlock(&external_command_buffer.buffer_lock);
  }

  // generate check statistics
  generate_check_stats();

  time_t current_time;
  time(&current_time);

  // write version info to status file
  fmt::format_to(
      buf,
      "#############################################\n"
      "#        CENTREON ENGINE STATUS FILE        #\n"
      "#                                           #\n"
      "# THIS FILE IS AUTOMATICALLY GENERATED BY   #\n"
      "# CENTREON ENGINE. DO NOT MODIFY THIS FILE! #\n"
      "#############################################\n"
      "\n"
      "info {{\n"
      "\tcreated={current_time}\n"
      "\t}}\n\n"
      "programstatus {{\n"
      "\tmodified_host_attributes={modified_host_process_attributes}\n"
      "\tmodified_service_attributes={modified_service_process_attributes}\n"
      "\tnagios_pid={pid}\n"
      "\tprogram_start={program_start}\n"
      "\tgrpc_port={grpc_port}\n"
      "\tlast_command_check={last_command_check}\n"
      "\tlast_log_rotation={last_log_rotation}\n"
      "\tenable_notifications={enable_notifications}\n"
      "\tactive_service_checks_enabled={execute_service_checks}\n"
      "\tpassive_service_checks_enabled={accept_passive_service_checks}\n"
      "\tactive_host_checks_enabled={execute_host_checks}\n"
      "\tpassive_host_checks_enabled={accept_passive_host_checks}\n"
      "\tenable_event_handlers={enable_event_handlers}\n"
      "\tobsess_over_services={obsess_over_services}\n"
      "\tobsess_over_hosts={obsess_over_hosts}\n"
      "\tcheck_service_freshness={check_service_freshness}\n"
      "\tcheck_host_freshness={check_host_freshness}\n"
      "\tenable_flap_detection={enable_flap_detection}\n"
      "\tprocess_performance_data={process_performance_data}\n"
      "\tglobal_host_event_handler={global_host_event_handler}\n"
      "\tglobal_service_event_handler={global_service_event_handler}\n"
      "\tnext_comment_id={next_comment_id}\n"
      "\tnext_event_id={next_event_id}\n"
      "\tnext_problem_id={next_problem_id}\n"
      "\tnext_notification_id={next_notification_id}\n"
      "\ttotal_external_command_buffer_slots={external_command_buffer_slots}\n"
      "\tused_external_command_buffer_slots={u_external_command_buffer_slots}\n"
      "\thigh_external_command_buffer_slots={h_external_command_buffer_slots}\n"
      "\tactive_scheduled_host_check_stats={ashcs0},{ashcs1},{ashcs2}\n"
      "\tactive_ondemand_host_check_stats={aohcs0},{aohcs1},{aohcs2}\n"
      "\tpassive_host_check_stats={phcs0},{phcs1},{phcs2}\n"
      "\tactive_scheduled_service_check_stats={asscs0},{asscs1},{asscs2}\n"
      "\tactive_ondemand_service_check_stats={aoscs0},{aoscs1},{aoscs2}\n"
      "\tpassive_service_check_stats={pscs0},{pscs1},{pscs2}\n"
      "\tcached_host_check_stats={achcs0},{achcs1},{achcs2}\n"
      "\tcached_service_check_stats={acscs0},{acscs1},{acscs2}\n"
     "\texternal_command_stats={ecs0},{ecs1},{ecs2}\n"
      "\tparallel_host_check_stats={pahcs0},{pahcs1},{pahcs2}\n"
      "\tserial_host_check_stats={shcs0},{shcs1},{shcs2}\n"
      "\t}}\n\n",
      fmt::arg("current_time", static_cast<unsigned long>(current_time)),
      fmt::arg("modified_host_process_attributes",
               modified_host_process_attributes),
      fmt::arg("modified_service_process_attributes",
               modified_service_process_attributes),
      fmt::arg("pid", getpid()),
      fmt::arg("program_start", static_cast<long long>(program_start)),
      fmt::arg("grpc_port", grpc_port),
      fmt::arg("last_command_check",
               static_cast<long long>(last_command_check)),
      fmt::arg("last_log_rotation",
               static_cast<long long>(last_log_rotation)),
      fmt::arg("enable_notifications", static_cast<int32_t>(config->enable_notifications())),
      fmt::arg("execute_service_checks", static_cast<int32_t>(config->execute_service_checks())),
      fmt::arg("accept_passive_service_checks",
               static_cast<int32_t>(config->accept_passive_service_checks())),
      fmt::arg("execute_host_checks", static_cast<int32_t>(config->execute_host_checks())),
      fmt::arg("accept_passive_host_checks",
               static_cast<int32_t>(config->accept_passive_host_checks())),
      fmt::arg("enable_event_handlers", static_cast<int32_t>(config->enable_event_handlers())),
      fmt::arg("obsess_over_services", static_cast<int32_t>(config->obsess_over_services())),
      fmt::arg("obsess_over_hosts", static_cast<int32_t>(config->obsess_over_hosts())),
      fmt::arg("check_service_freshness", static_cast<int32_t>(config->check_service_freshness())),
      fmt::arg("check_host_freshness", static_cast<int32_t>(config->check_host_freshness())),
      fmt::arg("enable_flap_detection", static_cast<int32_t>(config->enable_flap_detection())),
      fmt::arg("process_performance_data", static_cast<int32_t>(config->process_performance_data())),
      fmt::arg("global_host_event_handler",
               config->global_host_event_handler()),
      fmt::arg("global_service_event_handler",
               config->global_service_event_handler()),
      fmt::arg("next_comment_id", comment::get_next_comment_id()),
      fmt::arg("next_event_id", next_event_id),
      fmt::arg("next_problem_id", next_problem_id),
      fmt::arg("next_notification_id", next_notification_id),
      fmt::arg("external_command_buffer_slots",
               config->external_command_buffer_slots()),
      fmt::arg("u_external_command_buffer_slots",
               used_external_command_buffer_slots),
      fmt::arg("h_external_command_buffer_slots",
               high_external_command_buffer_slots),
      fmt::arg("ashcs0", check_statistics[ACTIVE_SCHEDULED_HOST_CHECK_STATS].minute_stats[0]),
      fmt::arg("ashcs1", check_statistics[ACTIVE_SCHEDULED_HOST_CHECK_STATS].minute_stats[1]),
      fmt::arg("ashcs2", check_statistics[ACTIVE_SCHEDULED_HOST_CHECK_STATS].minute_stats[2]),
      fmt::arg("aohcs0", check_statistics[ACTIVE_ONDEMAND_HOST_CHECK_STATS].minute_stats[0]),
      fmt::arg("aohcs1", check_statistics[ACTIVE_ONDEMAND_HOST_CHECK_STATS].minute_stats[1]),
      fmt::arg("aohcs2", check_statistics[ACTIVE_ONDEMAND_HOST_CHECK_STATS].minute_stats[2]),
      fmt::arg("phcs0", check_statistics[PASSIVE_HOST_CHECK_STATS].minute_stats[0]),
      fmt::arg("phcs1", check_statistics[PASSIVE_HOST_CHECK_STATS].minute_stats[1]),
      fmt::arg("phcs2", check_statistics[PASSIVE_HOST_CHECK_STATS].minute_stats[2]),
      fmt::arg("asscs0", check_statistics[ACTIVE_SCHEDULED_SERVICE_CHECK_STATS].minute_stats[0]),
      fmt::arg("asscs1", check_statistics[ACTIVE_SCHEDULED_SERVICE_CHECK_STATS].minute_stats[1]),
      fmt::arg("asscs2", check_statistics[ACTIVE_SCHEDULED_SERVICE_CHECK_STATS].minute_stats[2]),
      fmt::arg("aoscs0", check_statistics[ACTIVE_ONDEMAND_SERVICE_CHECK_STATS].minute_stats[0]),
      fmt::arg("aoscs1", check_statistics[ACTIVE_ONDEMAND_SERVICE_CHECK_STATS].minute_stats[1]),
      fmt::arg("aoscs2", check_statistics[ACTIVE_ONDEMAND_SERVICE_CHECK_STATS].minute_stats[2]),
      fmt::arg("pscs0", check_statistics[PASSIVE_SERVICE_CHECK_STATS].minute_stats[0]),
      fmt::arg("pscs1", check_statistics[PASSIVE_SERVICE_CHECK_STATS].minute_stats[1]),
      fmt::arg("pscs2", check_statistics[PASSIVE_SERVICE_CHECK_STATS].minute_stats[2]),
      fmt::arg("achcs0", check_statistics[ACTIVE_CACHED_HOST_CHECK_STATS].minute_stats[0]),
      fmt::arg("achcs1", check_statistics[ACTIVE_CACHED_HOST_CHECK_STATS].minute_stats[1]),
      fmt::arg("achcs2", check_statistics[ACTIVE_CACHED_HOST_CHECK_STATS].minute_stats[2]),
      fmt::arg("acscs0", check_statistics[ACTIVE_CACHED_SERVICE_CHECK_STATS].minute_stats[0]),
      fmt::arg("acscs1", check_statistics[ACTIVE_CACHED_SERVICE_CHECK_STATS].minute_stats[1]),
      fmt::arg("acscs2", check_statistics[ACTIVE_CACHED_SERVICE_CHECK_STATS].minute_stats[2]),
      fmt::arg("ecs0", check_statistics[EXTERNAL_COMMAND_STATS].minute_stats[0]),
      fmt::arg("ecs1", check_statistics[EXTERNAL_COMMAND_STATS].minute_stats[1]),
      fmt::arg("ecs2", check_statistics[EXTERNAL_COMMAND_STATS].minute_stats[2]),
      fmt::arg("pahcs0", check_statistics[PARALLEL_HOST_CHECK_STATS].minute_stats[0]),
      fmt::arg("pahcs1", check_statistics[PARALLEL_HOST_CHECK_STATS].minute_stats[1]),
      fmt::arg("pahcs2", check_statistics[PARALLEL_HOST_CHECK_STATS].minute_stats[2]),
      fmt::arg("shcs0", check_statistics[SERIAL_HOST_CHECK_STATS].minute_stats[0]),
      fmt::arg("shcs1", check_statistics[SERIAL_HOST_CHECK_STATS].minute_stats[1]),
      fmt::arg("shcs2", check_statistics[SERIAL_HOST_CHECK_STATS].minute_stats[2]));

  /* save host status data */
  for (host_map::iterator it = com::centreon::engine::host::hosts.begin(),
                          end = com::centreon::engine::host::hosts.end();
       it != end; ++it) {
    fmt::format_to(
        buf,
        "hoststatus {{\n"
        "\thost_name={hostname}\n"
        "\tmodified_attributes={modif_attr}\n"
        "\tcheck_command={check_command}\n"
        "\tcheck_period={check_period}\n"
        "\tnotification_period={notification_period}\n"
        "\tcheck_interval={check_interval}\n"
        "\tretry_interval={retry_interval:.2f}\n"
        "\tevent_handler={event_handler}\n"
        "\thas_been_checked={has_been_checked}\n"
        "\tshould_be_scheduled={should_be_scheduled}\n"
        "\tcheck_execution_time={execution_time:.3f}\n"
        "\tcheck_latency={latency:.3f}\n"
        "\tcheck_type={check_type}\n"
        "\tcurrent_state={current_state}\n"
        "\tlast_hard_state={last_hard_state}\n"
        "\tlast_event_id={last_event_id}\n"
        "\tcurrent_event_id={current_event_id}\n"
        "\tcurrent_problem_id={current_problem_id}\n"
        "\tlast_problem_id={last_problem_id}\n"
        "\tplugin_output={plugin_output}\n"
        "\tlong_plugin_output={long_plugin_output}\n"
        "\tperformance_data={performance_data}\n"
        "\tlast_check={last_check}\n"
        "\tnext_check={next_check}\n"
        "\tcheck_options={check_options}\n"
        "\tcurrent_attempt={current_attempt}\n"
        "\tmax_attempts={max_attempts}\n"
        "\tstate_type={state_type}\n"
        "\tlast_state_change={last_state_change}\n"
        "\tlast_hard_state_change={last_hard_state_change}\n"
        "\tlast_time_up={last_time_up}\n"
        "\tlast_time_down={last_time_down}\n"
        "\tlast_time_unreachable={last_time_unreachable}\n"
        "\tlast_notification={last_notification}\n"
        "\tnext_notification={next_notification}\n"
        "\tno_more_notifications={no_more_notifications}\n"
        "\tcurrent_notification_number={current_notification_number}\n"
        "\tcurrent_notification_id={current_notification_id}\n"
        "\tnotifications_enabled={notifications_enabled}\n"
        "\tproblem_has_been_acknowledged={problem_has_been_acknowledged}\n"
        "\tacknowledgement_type={acknowledgement_type}\n"
        "\tactive_checks_enabled={active_checks_enabled}\n"
        "\tpassive_checks_enabled={passive_checks_enabled}\n"
        "\tevent_handler_enabled={event_handler_enabled}\n"
        "\tflap_detection_enabled={flap_detection_enabled}\n"
        "\tprocess_performance_data={process_performance_data}\n"
        "\tobsess_over_host={obsess_over_host}\n"
        "\tlast_update={last_update}\n"
        "\tis_flapping={is_flapping}\n"
        "\tpercent_state_change={percent_state_change:.2f}\n"
        "\tscheduled_downtime_depth={scheduled_downtime_depth}\n",
        fmt::arg("hostname", it->second->get_name()),
        fmt::arg("modif_attr", it->second->get_modified_attributes()),
        fmt::arg("check_command", it->second->get_check_command()),
        fmt::arg("check_period", it->second->get_check_period()),
        fmt::arg("notification_period", it->second->get_notification_period()),
        fmt::arg("check_interval", it->second->get_check_interval()),
        fmt::arg("retry_interval", it->second->get_retry_interval()),
        fmt::arg("event_handler", it->second->get_event_handler()),
        fmt::arg("has_been_checked", static_cast<int32_t>(it->second->has_been_checked())),
        fmt::arg("should_be_scheduled", static_cast<int32_t>(it->second->get_should_be_scheduled())),
        fmt::arg("execution_time", it->second->get_execution_time()),
        fmt::arg("latency", it->second->get_latency()),
        fmt::arg("check_type", it->second->get_check_type()),
        fmt::arg("current_state", it->second->get_current_state()),
        fmt::arg("last_hard_state", it->second->get_last_hard_state()),
        fmt::arg("last_event_id", it->second->get_last_event_id()),
        fmt::arg("current_event_id", it->second->get_current_event_id()),
        fmt::arg("current_problem_id", it->second->get_current_problem_id()),
        fmt::arg("last_problem_id", it->second->get_last_problem_id()),
        fmt::arg("plugin_output", it->second->get_plugin_output()),
        fmt::arg("long_plugin_output", it->second->get_long_plugin_output()),
        fmt::arg("performance_data", it->second->get_perf_data()),
        fmt::arg("last_check",
                 static_cast<unsigned long>(it->second->get_last_check())),
        fmt::arg("next_check",
                 static_cast<unsigned long>(it->second->get_next_check())),
        fmt::arg("check_options", it->second->get_check_options()),
        fmt::arg("current_attempt", it->second->get_current_attempt()),
        fmt::arg("max_attempts", it->second->get_max_attempts()),
        fmt::arg("state_type", it->second->get_state_type()),
        fmt::arg("last_state_change", static_cast<unsigned long>(
                                          it->second->get_last_state_change())),
        fmt::arg("last_hard_state_change",
                 static_cast<unsigned long>(
                     it->second->get_last_hard_state_change())),
        fmt::arg("last_time_up",
                 static_cast<unsigned long>(it->second->get_last_time_up())),
        fmt::arg("last_time_down",
                 static_cast<unsigned long>(it->second->get_last_time_down())),
        fmt::arg("last_time_unreachable",
                 static_cast<unsigned long>(
                     it->second->get_last_time_unreachable())),
        fmt::arg("last_notification", static_cast<unsigned long>(
                                          it->second->get_last_notification())),
        fmt::arg("next_notification", static_cast<unsigned long>(
                                          it->second->get_next_notification())),
        fmt::arg("no_more_notifications",
                 static_cast<int32_t>(it->second->get_no_more_notifications())),
        fmt::arg("current_notification_number",
                 it->second->get_notification_number()),
        fmt::arg("current_notification_id",
                 it->second->get_current_notification_id()),
        fmt::arg("notifications_enabled",
                 static_cast<int32_t>(it->second->get_notifications_enabled())),
        fmt::arg("problem_has_been_acknowledged",
                 static_cast<int32_t>(it->second->get_problem_has_been_acknowledged())),
        fmt::arg("acknowledgement_type",
                 it->second->get_acknowledgement_type()),
        fmt::arg("active_checks_enabled", static_cast<int32_t>(it->second->get_checks_enabled())),
        fmt::arg("passive_checks_enabled",
                 static_cast<int32_t>(it->second->get_accept_passive_checks())),
        fmt::arg("event_handler_enabled",
                 static_cast<int32_t>(it->second->get_event_handler_enabled())),
        fmt::arg("flap_detection_enabled",
                 static_cast<int32_t>(it->second->get_flap_detection_enabled())),
        fmt::arg("process_performance_data",
                 static_cast<int32_t>(it->second->get_process_performance_data())),
        fmt::arg("obsess_over_host", static_cast<int32_t>(it->second->get_obsess_over())),
        fmt::arg("last_update", static_cast<unsigned long>(current_time)),
        fmt::arg("is_flapping", static_cast<int32_t>(it->second->get_is_flapping())),
        fmt::arg("percent_state_change",
                 it->second->get_percent_state_change()),
        fmt::arg("scheduled_downtime_depth",
                 it->second->get_scheduled_downtime_depth()));

    // custom variables
    for (auto const& cv : it->second->custom_variables) {
      if (!cv.first.empty())
        fmt::format_to(buf, "\t_{}={};{}\n", cv.first,
                       static_cast<int32_t>(cv.second.has_been_modified()), cv.second.get_value());
    }
    fmt::format_to(buf, "\t}}\n\n");
  }

  // save service status data
  for (service_map::iterator it(service::services.begin()),
       end(service::services.end());
       it != end; ++it) {
    fmt::format_to(
        buf,
        "servicestatus {{\n"
        "\thost_name={host_name}\n"
        "\tservice_description={service_description}\n"
        "\tmodified_attributes={modified_attributes}\n"
        "\tcheck_command={check_command}\n"
        "\tcheck_period={check_period}\n"
        "\tnotification_period={notification_period}\n"
        "\tcheck_interval={check_interval}\n"
        "\tretry_interval={retry_interval:.2f}\n"
        "\tevent_handler={event_handler}\n"
        "\thas_been_checked={has_been_checked}\n"
        "\tshould_be_scheduled={should_be_scheduled}\n"
        "\tcheck_execution_time={check_execution_time:.3f}\n"
        "\tcheck_latency={check_latency:.3f}\n"
        "\tcheck_type={check_type}\n"
        "\tcurrent_state={current_state}\n"
        "\tlast_hard_state={last_hard_state}\n"
        "\tlast_event_id={last_event_id}\n"
        "\tcurrent_event_id={current_event_id}\n"
        "\tcurrent_problem_id={current_problem_id}\n"
        "\tlast_problem_id={last_problem_id}\n"
        "\tcurrent_attempt={current_attempt}\n"
        "\tmax_attempts={max_attempts}\n"
        "\tstate_type={state_type}\n"
        "\tlast_state_change={last_state_change}\n"
        "\tlast_hard_state_change={last_hard_state_change}\n"
        "\tlast_time_ok={last_time_ok}\n"
        "\tlast_time_warning={last_time_warning}\n"
        "\tlast_time_unknown={last_time_unknown}\n"
        "\tlast_time_critical={last_time_critical}\n"
        "\tplugin_output={plugin_output}\n"
        "\tlong_plugin_output={long_plugin_output}\n"
        "\tperformance_data={performance_data}\n"
        "\tlast_check={last_check}\n"
        "\tnext_check={next_check}\n"
        "\tcheck_options={check_options}\n"
        "\tcurrent_notification_number={current_notification_number}\n"
        "\tcurrent_notification_id={current_notification_id}\n"
        "\tlast_notification={last_notification}\n"
        "\tnext_notification={next_notification}\n"
        "\tno_more_notifications={no_more_notifications}\n"
        "\tnotifications_enabled={notifications_enabled}\n"
        "\tactive_checks_enabled={active_checks_enabled}\n"
        "\tpassive_checks_enabled={passive_checks_enabled}\n"
        "\tevent_handler_enabled={event_handler_enabled}\n"
        "\tproblem_has_been_acknowledged={problem_has_been_acknowledged}\n"
        "\tacknowledgement_type={acknowledgement_type}\n"
        "\tflap_detection_enabled={flap_detection_enabled}\n"
        "\tprocess_performance_data={process_performance_data}\n"
        "\tobsess_over_service={obsess_over_service}\n"
        "\tlast_update={last_update}\n"
        "\tis_flapping={is_flapping}\n"
        "\tpercent_state_change={percent_state_change:.2f}\n"
        "\tscheduled_downtime_depth={scheduled_downtime_depth}\n",
        fmt::arg("host_name", it->second->get_hostname()),
        fmt::arg("service_description", it->second->get_description()),
        fmt::arg("modified_attributes", it->second->get_modified_attributes()),
        fmt::arg("check_command", it->second->get_check_command()),
        fmt::arg("check_period", it->second->get_check_period()),
        fmt::arg("notification_period", it->second->get_notification_period()),
        fmt::arg("check_interval", it->second->get_check_interval()),
        fmt::arg("retry_interval", it->second->get_retry_interval()),
        fmt::arg("event_handler", it->second->get_event_handler()),
        fmt::arg("has_been_checked", static_cast<int32_t>(it->second->has_been_checked())),
        fmt::arg("should_be_scheduled", static_cast<int32_t>(it->second->get_should_be_scheduled())),
        fmt::arg("check_execution_time", it->second->get_execution_time()),
        fmt::arg("check_latency", it->second->get_latency()),
        fmt::arg("check_type", it->second->get_check_type()),
        fmt::arg("current_state", it->second->get_current_state()),
        fmt::arg("last_hard_state", it->second->get_last_hard_state()),
        fmt::arg("last_event_id", it->second->get_last_event_id()),
        fmt::arg("current_event_id", it->second->get_current_event_id()),
        fmt::arg("current_problem_id", it->second->get_current_problem_id()),
        fmt::arg("last_problem_id", it->second->get_last_problem_id()),
        fmt::arg("current_attempt", it->second->get_current_attempt()),
        fmt::arg("max_attempts", it->second->get_max_attempts()),
        fmt::arg("state_type", it->second->get_state_type()),
        fmt::arg("last_state_change", static_cast<unsigned long>(
                                          it->second->get_last_state_change())),
        fmt::arg("last_hard_state_change",
                 static_cast<unsigned long>(
                     it->second->get_last_hard_state_change())),
        fmt::arg("last_time_ok",
                 static_cast<unsigned long>(it->second->get_last_time_ok())),
        fmt::arg("last_time_warning", static_cast<unsigned long>(
                                          it->second->get_last_time_warning())),
        fmt::arg("last_time_unknown", static_cast<unsigned long>(
                                          it->second->get_last_time_unknown())),
        fmt::arg(
            "last_time_critical",
            static_cast<unsigned long>(it->second->get_last_time_critical())),
        fmt::arg("plugin_output", it->second->get_plugin_output()),
        fmt::arg("long_plugin_output", it->second->get_long_plugin_output()),
        fmt::arg("performance_data", it->second->get_perf_data()),
        fmt::arg("last_check",
                 static_cast<unsigned long>(it->second->get_last_check())),
        fmt::arg("next_check",
                 static_cast<unsigned long>(it->second->get_next_check())),
        fmt::arg("check_options", it->second->get_check_options()),
        fmt::arg("current_notification_number",
                 it->second->get_notification_number()),
        fmt::arg("current_notification_id",
                 it->second->get_current_notification_id()),
        fmt::arg("last_notification", static_cast<unsigned long>(
                                          it->second->get_last_notification())),
        fmt::arg("next_notification", static_cast<unsigned long>(
                                          it->second->get_next_notification())),
        fmt::arg("no_more_notifications",
                 static_cast<int32_t>(it->second->get_no_more_notifications())),
        fmt::arg("notifications_enabled",
                 static_cast<int32_t>(it->second->get_notifications_enabled())),
        fmt::arg("active_checks_enabled", static_cast<int32_t>(it->second->get_checks_enabled())),
        fmt::arg("passive_checks_enabled",
                 static_cast<int32_t>(it->second->get_accept_passive_checks())),
        fmt::arg("event_handler_enabled",
                 static_cast<int32_t>(it->second->get_event_handler_enabled())),
        fmt::arg("problem_has_been_acknowledged",
                 static_cast<int32_t>(it->second->get_problem_has_been_acknowledged())),
        fmt::arg("acknowledgement_type",
                 it->second->get_acknowledgement_type()),
        fmt::arg("flap_detection_enabled",
                 static_cast<int32_t>(it->second->get_flap_detection_enabled())),
        fmt::arg("process_performance_data",
                 static_cast<int32_t>(it->second->get_process_performance_data())),
        fmt::arg("obsess_over_service", static_cast<int32_t>(it->second->get_obsess_over())),
        fmt::arg("last_update", static_cast<unsigned long>(current_time)),
        fmt::arg("is_flapping", static_cast<int32_t>(it->second->get_is_flapping())),
        fmt::arg("percent_state_change",
                 it->second->get_percent_state_change()),
        fmt::arg("scheduled_downtime_depth",
                 it->second->get_scheduled_downtime_depth()));

    // custom variables
    for (auto const& cv : it->second->custom_variables) {
      if (!cv.first.empty())
        fmt::format_to(buf, "\t_{}={};{}\n",
            cv.first, static_cast<int32_t>(cv.second.has_been_modified()), cv.second.get_value());
    }
    fmt::format_to(buf, "\t}}\n\n");
  }

  // save contact status data
  for (contact_map::const_iterator it = contact::contacts.begin(),
                                   end = contact::contacts.end();
       it != end; ++it) {
    contact* cntct(it->second.get());
    fmt::format_to(
        buf,
        "contactstatus {{\n"
        "\tcontact_name={contact_name}\n"
        "\tmodified_attributes={modified_attributes}\n"
        "\tmodified_host_attributes={modified_host_attributes}\n"
        "\tmodified_service_attributes={modified_service_attributes}\n"
        "\thost_notification_period={host_notification_period}\n"
        "\tservice_notification_period={service_notification_period}\n"
        "\tlast_host_notification={last_host_notification}\n"
        "\tlast_service_notification={last_service_notification}\n"
        "\thost_notifications_enabled={host_notifications_enabled}\n"
        "\tservice_notifications_enabled={service_notifications_enabled}\n",

        fmt::arg("contact_name", cntct->get_name()),
        fmt::arg("modified_attributes", cntct->get_modified_attributes()),
        fmt::arg("modified_host_attributes",
                 cntct->get_modified_host_attributes()),
        fmt::arg("modified_service_attributes",
                 cntct->get_modified_service_attributes()),
        fmt::arg("host_notification_period",
                 cntct->get_host_notification_period()),
        fmt::arg("service_notification_period",
                 cntct->get_service_notification_period()),
        fmt::arg(
            "last_host_notification",
            static_cast<unsigned long>(cntct->get_last_host_notification())),
        fmt::arg(
            "last_service_notification",
            static_cast<unsigned long>(cntct->get_last_service_notification())),
        fmt::arg("host_notifications_enabled",
                 static_cast<int32_t>(cntct->get_host_notifications_enabled())),
        fmt::arg("service_notifications_enabled",
                 static_cast<int32_t>(cntct->get_service_notifications_enabled())));

    // custom variables
    for (auto const& cv : cntct->get_custom_variables()) {
      if (!cv.first.empty())
        fmt::format_to(buf, "\t_{}={};{}\n", cv.first,
                       static_cast<uint32_t>(cv.second.has_been_modified()),
                       cv.second.get_value());
    }
    fmt::format_to(buf, "\t}}\n\n");
  }

  // save all comments
  for (comment_map::iterator it(comment::comments.begin()),
       end(comment::comments.end());
       it != end; ++it) {
    if (it->second->get_comment_type() == com::centreon::engine::comment::host)
      fmt::format_to(buf, "hostcomment {{\n\thost_id={}\n",
                     it->second->get_host_id());
    else
      fmt::format_to(buf, "servicecomment {{\n\thost_id={}\n\tservice_id={}\n",
                     it->second->get_host_id(), it->second->get_service_id());

    fmt::format_to(
        buf,
        "\tentry_type={entry_type}\n"
        "\tcomment_id={comment_id}\n"
        "\tsource={source}\n"
        "\tpersistent={persistent}\n"
        "\tentry_time={entry_time}\n"
        "\texpires={expires}\n"
        "\texpire_time={expire_time}\n"
        "\tauthor={author}\n"
        "\tcomment_data={comment_data}\n"
        "\t}}\n\n",
        fmt::arg("entry_type", it->second->get_entry_type()),
        fmt::arg("comment_id", it->first),
        fmt::arg("source", it->second->get_source()),
        fmt::arg("persistent", static_cast<uint32_t>(it->second->get_persistent())),
        fmt::arg("entry_time",
                 static_cast<unsigned long>(it->second->get_entry_time())),
        fmt::arg("expires", static_cast<uint32_t>(it->second->get_expires())),
        fmt::arg("expire_time",
                 static_cast<unsigned long>(it->second->get_expire_time())),
        fmt::arg("author", it->second->get_author()),
        fmt::arg("comment_data", it->second->get_comment_data()));
  }

  // save all downtime
  for (std::pair<time_t, std::shared_ptr<downtime>> const& dt :
       downtime_manager::instance().get_scheduled_downtimes()) {
    switch (dt.second->get_type()) {
      case downtime::service_downtime:
        {
          service_downtime* sd = static_cast<service_downtime*>(dt.second.get());
        fmt::format_to(
            buf,
            "servicedowntime {{\n\thost_name={}\n\tservice_description={}\n",
            sd->get_hostname(), sd->get_service_description());
        }
        break;
      case downtime::host_downtime:
        fmt::format_to(buf, "hostdowntime {{\n\thost_name={}\n",
                       dt.second->get_hostname());
        break;
      default:
        break;  // should not arrive
    }
    fmt::format_to(
        buf,
        "\tdowntime_id={downtime_id}\n"
        "\tentry_time={entry_time}\n"
        "\tstart_time={start_time}\n"
        "\tend_time={end_time}\n"
        "\ttriggered_by={triggered_by}\n"
        "\tfixed={fixed}\n"
        "\tduration={duration}\n"
        "\tauthor={author}\n"
        "\tcomment={comment}\n"
        "\t}}\n\n",
        fmt::arg("downtime_id", dt.second->get_downtime_id()),
        fmt::arg("entry_time", static_cast<unsigned long>(dt.second->get_entry_time())),
        fmt::arg("start_time", static_cast<unsigned long>(dt.second->get_start_time())),
        fmt::arg("end_time", static_cast<unsigned long>(dt.second->get_end_time())),
        fmt::arg("triggered_by", dt.second->get_triggered_by()),
        fmt::arg("fixed", dt.second->is_fixed()), fmt::arg("duration", dt.second->get_duration()),
        fmt::arg("author", dt.second->get_author()),
        fmt::arg("comment", dt.second->get_comment()));
  }

  // Prepare status file for overwrite.
  if (ftruncate(xsddefault_status_log_fd, 0) == -1 ||
      fsync(xsddefault_status_log_fd) == -1 ||
      lseek(xsddefault_status_log_fd, 0, SEEK_SET) == (off_t)-1) {
    char const* msg(strerror(errno));
    logger(engine::logging::log_runtime_error, engine::logging::basic)
        << "Error: Unable to update status data file '" << config->status_file()
        << "': " << msg;
    return ERROR;
  }

  // Write status file.
  char const* data_ptr(buf.data());
  size_t size(buf.size());
  while (size > 0) {
    ssize_t wb(write(xsddefault_status_log_fd, data_ptr, size));
    if (wb <= 0) {
      char const* msg(strerror(errno));
      logger(engine::logging::log_runtime_error, engine::logging::basic)
          << "Error: Unable to update status data file '"
          << config->status_file() << "': " << msg;
      return ERROR;
    }
    data_ptr += wb;
    size -= wb;
  }

  auto finish = std::chrono::steady_clock::now();
  time_t now = time(nullptr);
  std::cout << "### Status file Duration : " << std::chrono::duration_cast<std::chrono::duration<double>>(finish-start).count() << " ; " << (now - program_start) << std::endl;

  return OK;
}
